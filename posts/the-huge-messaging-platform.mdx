---
title: 대규모 채팅 플랫폼 작성
excerpt: 대규모 커뮤니케이션 플랫폼에서 사용될 아키텍쳐와 방식들을 직접 구상하고 작성해보았습니다.
image:
date: 2021-10-07
---

# Concept

그 어떤 사람이라도 한 번쯤은 대규모 애플리케이션을 작성해보고 테스트해보고 싶을 때가 있을 것입니다.
그리고 요즘 저는 다시 이전에 아쉬웠던 프로젝트 중 하나인 채팅 애플리케이션을 더욱 더 덜 아쉽게 만들어보기로 했습니다.
성능 그리고 아키텍쳐까지 모든 부분에서 애플리케이션을 향상시키고 싶었습니다.
저의 목표는 어떠한 규모에서도 최소한의 자원으로 가볍게 클러스터링하고 동작하는 애플리케이션입니다.

## 성능과 자원 사이, 더 중요한 것은?

가장 먼저 설정해야 할 것은 "규모" 자체입니다.
그 이유는 애플리케이션을 개발하는데에 있어서 그 규모는 어떤 스택을 사용할지 그리고 그 스택들에 따라서 개발 시간까지 달라지기 때문입니다.
물론 그 어떤 애플리케이션이라도 최상의 솔루션을 사용한다면 좋겠지만 제품이 서비스에 도달하는 시간을 고려했을 때 그것은 단순히 성능을 위한 억지에 불과합니다.
서비스에 도달하지 못하는 제품은 사용하지 못하게 되고 결국 제품은 사용자를 만나지 못한 채 종료될 것입니다.

그러나 개발자로서 지금 저에게 중요한 것은 서비스 도달 시간이 아닙니다.
제가 원하는 것은 성능과 자원으로 2가지였습니다.
그리고 마지막으로 "그 어떤 규모에서라도"라는 말을 덧붙였죠.
이 말이 내포하는 것은 많은 자원을 고려할 수 없는 소규모 환경에서도 애플리케이션은 가볍게 동작해야 한다는 것을 뜻합니다.

예를 들어서 메모리가 2GB인 VPS에서 동작하는 것을 생각해볼 수 있습니다.
서버는 ELK 스택을 돌리기조차 버거울 것이며 설상 돌린다 하더라도 실 서비스에 영향을 미칠 것입니다.
이러한 경우에 저희는 ELK 스택을 과감히 포기하고 경량의 솔루션을 적용해야 합니다.
즉, 효율적인 도구가 존재할 수 있으나 소규모에서도 그것을 충분히 운용 가능해야 한다는 뜻입니다.
비슷한 사례로 Kafka 등 또한 분명 포함이 될 것입니다.

물론 경량 솔루션을 직접 작업하는 것은 이미 나와있는 상용 솔루션을 쓰는 것보단 힘든 일이 될 것입니다.
하지만 하나의 커리어로써 생각을 해보았을 때 이는 전혀 저에게 해가 아니라고 판단했고 저는 직접 솔루션 작성을 진행하기로 결정했습니다.

## 이미 무료로 제공됩니다만?

그 많은 제품들 중에서 왜 하필 채팅 애플리케이션을 선택했을까요? 이미 세상에는 대규모의, 그것도 무료인 채팅 애플리케이션 서비스가 정말로 많이 있습니다.

- [Discord](https://discord.com/)
- [Slack](https://slack.com/)
- [Mattermost](https://mattermost.com/)

### #1 해보지 않았어요

어떤 사람들은 여전히 이렇게 생각할 수도 있습니다: 이미 있는데 굳이 왜 만들지?
그런데 반대로 그럼 그렇게 흔한 서비스니까 그냥 만들 수 있을까요?
이 점에서 첫 번째로 저는 도전해보고 싶다는 생각이 들었습니다.
커뮤니케이션 플랫폼은 무료인데다가 흔하고 심지어 대부분은 전세계 어디에서나 저지연 상태로 제공됩니다.
하지만 그렇게 흔한 것도 저는 만들 수 있는 상태 혹은 준비조차 되어 있지 않았습니다.

**첫 번째 이유는 제가 만들지 못하기 때문입니다.**
다시 말하면 제가 이러한 제품이 어떻게 동작하는지 한 번이라도 신경써서 생각해본 적이 없다는 것을 뜻한다는 것입니다.
실제로 가볍게 "언제나 이렇게 작동할 것이다"는 쉽지만 상세히 "이렇게 작동할 것이다"는 해본 적이 없습니다.

### #2 필요할 때 없어요

여전히 저는 솔루션을 여러 개 사용합니다.
그리고 언제나 생각하곤 합니다:

- 이 API는 조금 더 나에게 많은 권한을 주었으면
- 왜 하필 이런 때에 터지는거지
- 디자인이 맘에 들지 않아

당연히 메신저들은 대부분 회사에 의해서 운영되고 그 회사나 조직의 사정에 따라서 업데이트가 진행됩니다.
제가 이에 대해서 심지어 무료로 사용 중이면서 제 뜻대로 움직이는 것을 바라는 것은 바람직하지 않다고 생각합니다.
또 언제나 아쉬운 점이 생기고 조직을 운영하다보면 분명히 언제나 우리만의 "플랫폼"이 있었다면 좋겠다고 생각하곤 합니다.
다시 생각해보면 언제나 있었으면 좋겠다고 생각한 것은 저만의 "플랫폼"이자 "메신저"가 아니었나 싶습니다.

**두 번째 이유는 제가 만들어야 제가 바꿀 수 있기 때문입니다.**
직접 만들면 제가 책임을 지고 바꿀 수 있습니다.
무언가 문제가 있다면 해결책을 동시에 제시하는 것이 당연하다고 생각하며 언제나 존재하던 니즈에 대한 충족까지 가능합니다.

### #3 어려워요

마지막 이유로는 어렵습니다.
네, 정말로 어려운 과제 중 하나라고 생각합니다.
제가 어렵다고 말하는 프로젝트는 대개 저만의 기준에 따라서 다음과 같은 프로젝트가 해당되곤 합니다:

- 실시간 처리
- 비정형 데이터 처리
- 중앙 처리
- 저지연

그리고 채팅 애플리케이션은 위 조건에 모두 충족하는 애플리케이션 중 하나입니다.
채팅 애플리케이션에서 저희는 사진을 업로드하기도 하고 메세지를 실시간으로 받아보기도 하며 심지어는 통화까지 합니다.
여기에 하나 더 얹어서 전세계에서 이런 이들이 1초 안에 모두 일어납니다.
하나만 더 얹어서 솔직히 고백하자면 이러한 것을 만드는 것을 상당히 좋아하기도 합니다.

**세 번째 이유는 환상적이면서 어렵기 때문입니다.**
쉬운 문제를 해결하는 것은 저를 방심하게 합니다.
계속 생각하는 사람이 되고 어려운 문제를 헤쳐나아가는 사람이 되고 싶습니다.

----

# Blueprint

생각을 했으면 이제 이것을 실현시켜볼 차례입니다.
여전히 "규모"를 생각하는 것이 1순위이고 기존에 제가 작성하던 백엔드와는 분명히 두드러지는 몇 가지 차이점이 있었습니다.
그리고 마지막으로 제가 개인적으로 이루어보고 싶었던 것들이 더 있습니다.

## Multi-Master 데이터베이스 아키텍쳐

가장 첫 번째로 제 머릿속에 떠올랐던 것입니다.
바로 `multi-master` 구조입니다.

```
┌─────────────┐   ┌─────────────┐
│ Active Zone ├───┤ Active Zone │
└──────┬──────┘   └──────┬──────┘
       │                 │
┌──────┴─────────────────┴──────┐
│             Proxy             │
└───────────────┬───────────────┘
                │
┌───────────────┴───────────────┐
│          Application          │
└───────────────────────────────┘
```

`multi-master` 구조는 기존의 스케일링 방식과는 다르게 `active` 노드를 다중으로 사용하는 방식입니다.
이러한 방식을 사용하면 기존 `single master` 상황과는 별개로 데이터가 각각의 노드에 쌓을 수 있으므로 수평적 확장이 쉬워지고 데이터의 액세스가 한 서버 내에서만 이루어지지 않으므로 IO 로드 또한 분산시킬 수 있습니다.
애플리케이션이 얼마나 커질지 모르기 때문에 모든 노드끼리 서로 완전히 동기화를 보장하는 것보다는 각각의 노드에서 데이터를 서로 분담하는 것이 유리합니다.

아키텍쳐가 변동을 하면서 동시에 같이 변화하는 영역들이 있습니다.

### #1 Primary Key 결정하기

그 중 첫 번째는 바로 Primary Key에 관한 것입니다.
Primary Key는 거의 모든 DBMS에서 효율적인 데이터 로드를 위해 인덱스 등을 설정하는데에 사용되는 것으로 Primary Key의 데이터 형식뿐만 아니라 그것이 차지하는 용량 등이 큰 변수가 됩니다.
그 외에도 정렬이 가능한지 가능하지 않은지 등의 여부에 따라서 효율성이 극도로 차이나는 경우도 있습니다.

가장 중요한 것은 겹치지 않는 것으로 `active-active` 구조인 `multi-master`에서는 단순히 `auto_increase`(이하 `AI`)를 사용하는 것은 지연도와 성능면에서 큰 단점으로 작용합니다.
그리고 대규모의 데이터를 효율적으로 저장하기 위해서 Primary Key는 시간 등의 다른 데이터 또한 담을 수 있어야 합니다.

#### UUID, 128 bits string

Primary Key의 후보로 처음 고려한 것은 문자열, 그 중에서도 UUID입니다.
UUID는 32비트인 `int`보다 훨씬 더 큰 128비트의 공간을 차지하는 문자열로 고유 ID를 표현하기 위해 만들어졌습니다.

```
0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          time_low                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       time_mid                |         time_hi_and_version   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         node (2-5)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

위는 [IETF RFC4122](https://datatracker.ietf.org/doc/html/rfc4122)에서 가져온 UUID v1의 구조입니다.
특징으로보면 Timestamp가 포함되어 있어 시간 데이터 또한 동시에 나타낼 수 있어 데이터 저장 측면에서 효율성이 단순 `int`의 `AI`보다 높습니다.

* UUID는 v2까지는 시간 데이터가 포함되어 있습니다.

하지만 UUID를 다중 클러스터 환경에서 사용하는 것은 좋지 않습니다.
비록 난수 함수가 굉장히 광범위한 난수를 생성해낼 수 있음에도 불구하고 대부분의 프로그래밍 언어에서 난수 생성은 한 쪽에 치우쳐져 이루어집니다.
이는 정말로 난수를 만드는 알고리즘이 아니라 난수처럼 보이는 일련의 숫자 분포를 반환하기 때문입니다.
그 과정이 어찌한들 이는 공식적으로 정의된 프로토콜이며 중복 데이터가 생길 가능성이 매우 높기 때문에 고려 대상이 아닙니다.

#### nanoid, *string

그 무작위를 더욱 고르게 하기 위하여 난수 함수 대신 하드웨어 소음을 수집하여 난수를 생성하는 nanoid가 있습니다.
nanoid는 처음 Node.JS 구현을 시작으로 현재는 많은 프로그래밍 언어에서 광범위하게 사용되고 있습니다.
단순히 하드웨어 소음을 수집하기 때문에 난수 함수를 사용하는 것보다도 훨씬 가벼운 것이 특징이라고 할 수 있습니다.

```
// https://github.com/ai/nanoid#benchmark

$ node ./test/benchmark.js
crypto.randomUUID         28,387,114 ops/sec
uid/secure                 8,633,795 ops/sec
@lukeed/uuid               6,888,704 ops/sec
nanoid                     6,166,399 ops/sec
customAlphabet             3,290,342 ops/sec
uuid v4                    1,662,373 ops/sec
```

하지만 nanoid는 UUID처럼 최소한의 순서를 나타낼 수 있는 시간 데이터 또한 가지고 있지 않기 때문에 인덱싱 비용의 증가로 추후 기능 구현에서 걸림돌이 될 것이 분명하므로 아쉽지만 고려 대상이 될 수 없습니다.

<Button theme='black' icon={MdArrowForward} href='https://www.npmjs.com/package/nanoid'>NPM에서 nanoid 보기</Button>

#### Snowflake, 64bit int (BigInt)

그리고 문자열의 Primary Key 후보들과 다르게 64비트 정수로 표현되는 후보에는 Snowflake가 있습니다.
사실은 처음에 Snowflake를 사용하지 않으려고 했습니다.
그 이유는 단순합니다.
Node.JS에서 다루는 과정이 굉장히 귀찮기 때문입니다.
자칫 이 것이 단순히 BigInt라는 객체로 표현되지 않느냐라고 말할 수도 있지만 같은 Number를 다루는데 같은 방식을 차용할 수 없다는 것은 동시에 굉장한 스트레스가 될 것입니다.
